Software systems should separate {{c1::the startup process}}, when {{c1::the application objects are constructed and the dependencies are "wired" together}} from {{c1::the runtime logic that takes over after startup}}.	CleanCode	11	
Software systems are unique compared to {{c1::physical systems}}.  Their architectures can {{c1::grow incrementally}}, *if* {{c1::we maintain the proper separation of concerns}}.	CleanCode	11	
POJOs (Plain old Java objects) have no dependencies on {{c1::enterprise frameworks (or any other domain)}}.	CleanCode	11	
An optimal system architecture consists of modularized {{c1::domains of concern}}, each of which is implemented with {{c1::Plain Old Java (or other) Objects}}. The different {{c1::domains}} are integrated together with {{c1::minimally invasive Aspects or Aspect-like tools}}. This architecture can be {{c1::test-driven}}, just like the code.	CleanCode	11	
Standards make it easier to {{c1::reuse ideas and components, recruit people with relevant experience, encapsulate good ideas, and wire components together}}.  However, the process of creating standards can sometimes {{c1::take too long for industry to wait}}, and some standards {{c1::lose touch with the real needs of the adopters they are intended to serve}}.	CleanCode	11	
The agility provided by a POJO system with modularized concerns allows us to {{c1::make optimal, just-in-time decisions, based on the most recent knowledge.  The complexity of these decisions is also reduced}}.	CleanCode	11	
Domain-Specific Languages allow all levels of abstraction and all domains in the application {{c1::to be expressed as POJOs, from high-level policy to low-level details}}.	CleanCode	11	
A good Domain-Specific Language permits code to be written so that it reads {{c1::like a structured form of prose that a domain expert might write}}.	CleanCode	11	
